<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>A-LOAM算法分析 | LMay</title><meta name="keywords" content="SLAM,A-LOAM,算法分析"><meta name="author" content="LMay"><meta name="copyright" content="LMay"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="在思路，流程，代码上对A-LOAM算法进行分析">
<meta property="og:type" content="article">
<meta property="og:title" content="A-LOAM算法分析">
<meta property="og:url" content="http://lmay001.github.io/2022/09/26/20220926/index.html">
<meta property="og:site_name" content="LMay">
<meta property="og:description" content="在思路，流程，代码上对A-LOAM算法进行分析">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://tucang.cc/api/image/show/179aa07d6ac831122962767409dea79b">
<meta property="article:published_time" content="2022-09-26T11:04:33.000Z">
<meta property="article:modified_time" content="2022-10-03T05:30:13.487Z">
<meta property="article:author" content="LMay">
<meta property="article:tag" content="SLAM">
<meta property="article:tag" content="A-LOAM">
<meta property="article:tag" content="算法分析">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://tucang.cc/api/image/show/179aa07d6ac831122962767409dea79b"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://lmay001.github.io/2022/09/26/20220926/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'A-LOAM算法分析',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-10-03 13:30:13'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.2.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://tucang.cc/api/image/show/e7d7077461d1d59fa8f5859f9d60a15d" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">3</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">4</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-thin fa-address-card"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://tucang.cc/api/image/show/179aa07d6ac831122962767409dea79b')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">LMay</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-thin fa-address-card"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">A-LOAM算法分析</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-09-26T11:04:33.000Z" title="发表于 2022-09-26 19:04:33">2022-09-26</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-10-03T05:30:13.487Z" title="更新于 2022-10-03 13:30:13">2022-10-03</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/SLAM%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BB/">SLAM代码阅读</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="A-LOAM算法分析"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="A-LOAM算法分析"><a href="#A-LOAM算法分析" class="headerlink" title="A-LOAM算法分析"></a>A-LOAM算法分析</h1><h2 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h2><p><img src="/2022/09/26/20220926/A-LOAM%E6%80%9D%E8%B7%AF%E5%88%86%E6%9E%90.png" alt="A-LOAM思路分析"></p>
<p>因此，算法全程只在做一件事：求位姿变换</p>
<p>【注】位姿变换指的是每一帧点云在世界坐标系下的位姿，也可以理解为<code>点云所处的雷达坐标系</code>到<code>世界坐标系</code>下的变换</p>
<p><img src="/2022/09/26/20220926/%E7%82%B9%E4%BA%91%E9%85%8D%E5%87%86.png" alt="点云配准"></p>
<p>通过点云配准的方式求解位姿变换，点云配准一般分为粗配准和精配准，为了保证算法的实时性，采用二者结合的方式获得满足实时性要求的高精度地图</p>
<p>粗配准：高频率，低精度，计算量小，耗时短</p>
<p>精配准：低频率，高精度，计算量大，耗时长</p>
<h2 id="流程分析"><a href="#流程分析" class="headerlink" title="流程分析"></a>流程分析</h2><p><img src="/2022/09/26/20220926/%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90.png" alt="流程分析"></p>
<p>A-LOAM算法流程分为三部分：<code>数据预处理</code> ，<code>前端里程计</code> ，<code>后端优化与建图</code></p>
<p><strong>数据预处理</strong>：去除无效点，根据曲率提取特征点</p>
<p><strong>前端里程计</strong>：相邻两帧进行点云匹配，求得每相邻两帧的位姿变换</p>
<p><strong>后端优化与建图</strong>：当前帧与子图匹配，根据设定频率每隔几帧求得一帧的位姿变换，同时实现建图</p>
<h2 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h2><h3 id="scanRegistration"><a href="#scanRegistration" class="headerlink" title="scanRegistration"></a>scanRegistration</h3><p>主要功能：提取特征点，为后续节点的匹配做准备</p>
<p>提取特征点有以下要求：</p>
<ol>
<li>点云是处理过的有效的</li>
<li>特征点是根据扫描线划分且均匀分布的</li>
<li>特征点是根据曲率划分的</li>
<li>为了方便后续的匹配，计算每个点运动补偿的时间</li>
</ol>
<p>因此为完成提取特征点的功能，要有以下流程：<code>数据预处理</code>，<code>计算扫描线</code>，<code>计算运动补偿时间</code>，<code>计算曲率</code>，<code>提取特征点</code></p>
<h4 id="数据预处理"><a href="#数据预处理" class="headerlink" title="数据预处理"></a>数据预处理</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 去除 NAN点</span></span><br><span class="line">pcl::<span class="built_in">removeNaNFromPointCloud</span>(laserCloudIn, laserCloudIn, indices);</span><br><span class="line"><span class="comment">// 去除与雷达距离过近的点</span></span><br><span class="line"><span class="built_in">removeClosedPointCloud</span>(laserCloudIn, laserCloudIn, MINIMUM_RANGE);</span><br></pre></td></tr></table></figure>

<h4 id="计算扫描线与运动补偿时间"><a href="#计算扫描线与运动补偿时间" class="headerlink" title="计算扫描线与运动补偿时间"></a>计算扫描线与运动补偿时间</h4><p><img src="/2022/09/26/20220926/%E4%BF%AF%E4%BB%B0%E8%A7%92%E4%B8%8E%E6%B0%B4%E5%B9%B3%E8%A7%92.png" alt="俯仰角与水平角"></p>
<p><strong>俯仰角</strong>用于计算每个点所属扫描线，存储在每个点 <code>intensity</code> 属性的<strong>整数</strong>部分</p>
<p><strong>水平角</strong>用于计算每个点相对起始点的运动时间，存储在每个点 <code>intensity</code> 属性的<strong>小数</strong>部分</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计算起始点和结束点的水平角，方便后续计算运动补偿所需的时间间隔</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> cloudSize = laserCloudIn.points.<span class="built_in">size</span>();  <span class="comment">// 数据处理后点云中点的数量</span></span><br><span class="line">    <span class="comment">// 计算起始点和结束点的角度；结束点 + 2π 是为了保证起始到结束相差2π，更符合实际；</span></span><br><span class="line">    <span class="comment">// 负号是按激光雷达旋转方向取反，从顺时针变为逆时针</span></span><br><span class="line">    <span class="type">float</span> startOri = -<span class="built_in">atan2</span>(laserCloudIn.points[<span class="number">0</span>].y, laserCloudIn.points[<span class="number">0</span>].x);</span><br><span class="line">    <span class="type">float</span> endOri = -<span class="built_in">atan2</span>(laserCloudIn.points[cloudSize - <span class="number">1</span>].y, laserCloudIn.points[cloudSize - <span class="number">1</span>].x) + <span class="number">2</span> * M_PI;</span><br><span class="line">    <span class="comment">// 角度修正，以保持结束点的朝向和起始点的方向差始终在 2pi 附近</span></span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子点云,大小为扫描线数量，每个数组元素为一条扫描线上的点云</span></span><br><span class="line">std::vector&lt;pcl::PointCloud&lt;PointType&gt;&gt; <span class="built_in">laserCloudScans</span>(N_SCANS);  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历所有点，计算所属扫描线，及相对起始点的运动时间</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; cloudSize; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前点的俯仰角</span></span><br><span class="line">    <span class="type">float</span> angle = <span class="built_in">atan</span>(point.z / <span class="built_in">sqrt</span>(point.x * point.x + point.y * point.y)) * <span class="number">180</span> / M_PI;  </span><br><span class="line">    <span class="comment">// 计算当前点所属的扫描线</span></span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> ori = -<span class="built_in">atan2</span>(point.y, point.x);  <span class="comment">// 当前点的水平角</span></span><br><span class="line">    <span class="comment">// 角度修正</span></span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算该时刻相对起始时刻的时间间隔</span></span><br><span class="line">    <span class="type">float</span> relTime = (ori - startOri) / (endOri - startOri);</span><br><span class="line">    <span class="comment">// 小技巧：用 intensity的整数部分和小数部分来存储该点所属的扫描线以及相对时间</span></span><br><span class="line">    point.intensity = scanID + scanPeriod * relTime;</span><br><span class="line">    <span class="comment">// 根据scan的idx送入各自数组(子点云laserCloudScans)</span></span><br><span class="line">    laserCloudScans[scanID].<span class="built_in">push_back</span>(point);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="计算曲率"><a href="#计算曲率" class="headerlink" title="计算曲率"></a>计算曲率</h4><p>曲率计算方式：当前点与前后各五个点的距离平方和</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计算每个点的曲率，曲率表示方法为当前点和其周围 10 个点(左右各 5 个)的距离平方和</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">5</span>; i &lt; cloudSize - <span class="number">5</span>; i++)</span><br><span class="line">&#123; </span><br><span class="line">    <span class="type">float</span> diffX = ......;</span><br><span class="line">    <span class="type">float</span> diffY = ......;</span><br><span class="line">    <span class="type">float</span> diffZ = ......;</span><br><span class="line"></span><br><span class="line">    cloudCurvature[i] = diffX * diffX + diffY * diffY + diffZ * diffZ;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="提取特征点"><a href="#提取特征点" class="headerlink" title="提取特征点"></a>提取特征点</h4><p>根据曲率进行排序，提取特征点；曲率大的为边缘点，小的为平面点，以16线雷达为例，只从满足要求的扫描线上提取</p>
<p>一帧点云有 16 条扫描线，每一条扫描线分 6 个区域，每个区域提取要求：</p>
<ul>
<li>2 个极大边缘点</li>
<li>20 个次极大边缘点 (其中包括两个极大边缘点)</li>
<li>4个极小平面点</li>
<li>其余点均为次极小平面点</li>
</ul>
<p>【注】以上的边缘点和极小平面点都需要满足曲率满足阈值才取，而非必须取足够数量的点</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N_SCANS; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 不考虑少于 7 个点的扫描线</span></span><br><span class="line">    <span class="keyword">if</span>( scanEndInd[i] - scanStartInd[i] &lt; <span class="number">6</span>)</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    pcl::PointCloud&lt;PointType&gt;::<span class="function">Ptr <span class="title">surfPointsLessFlatScan</span><span class="params">(<span class="keyword">new</span> pcl::PointCloud&lt;PointType&gt;)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">6</span>; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 每个区域的起始和末尾指针</span></span><br><span class="line">        <span class="type">int</span> sp = scanStartInd[i] + (scanEndInd[i] - scanStartInd[i]) * j / <span class="number">6</span>; </span><br><span class="line">        <span class="type">int</span> ep = scanStartInd[i] + (scanEndInd[i] - scanStartInd[i]) * (j + <span class="number">1</span>) / <span class="number">6</span> - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 按照曲率对当前区域的点进行从小到大排序</span></span><br><span class="line">        std::<span class="built_in">sort</span> (cloudSortInd + sp, cloudSortInd + ep + <span class="number">1</span>, comp);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 挑选边缘点</span></span><br><span class="line">        <span class="type">int</span> largestPickedNum = <span class="number">0</span>;  <span class="comment">// 曲率较大点的数量</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> k = ep; k &gt;= sp; k--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 获得当前点在点云中索引</span></span><br><span class="line">            <span class="type">int</span> ind = cloudSortInd[k]; </span><br><span class="line"></span><br><span class="line">            <span class="comment">// 确认当前点没被选择过且曲率大于阈值</span></span><br><span class="line">            <span class="keyword">if</span> (cloudNeighborPicked[ind] == <span class="number">0</span> &amp;&amp; cloudCurvature[ind] &gt; <span class="number">0.1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                largestPickedNum++;</span><br><span class="line">                <span class="comment">// 取 2 个曲率最大的点 </span></span><br><span class="line">                <span class="keyword">if</span> (largestPickedNum &lt;= <span class="number">2</span>)</span><br><span class="line">                    <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 取 20 个曲率较大的点</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (largestPickedNum &lt;= <span class="number">20</span>)</span><br><span class="line">                        <span class="comment">// ......</span></span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                cloudNeighborPicked[ind] = <span class="number">1</span>;  <span class="comment">// 当前点筛选标志改为 1</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// 为了保证特征点不过度集中，将选中的点周围5个点都置1,避免后续会选到</span></span><br><span class="line">                <span class="comment">// 查看相邻点距离是否差异过大，如果差异过大说明点云在此不连续，是特征边缘，就会是新的特征，因此就不修改改标志</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> l = <span class="number">1</span>; l &lt;= <span class="number">5</span>; l++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="type">float</span> diffX = ......;</span><br><span class="line">                    <span class="type">float</span> diffY = ......;</span><br><span class="line">                    <span class="type">float</span> diffZ = ......;</span><br><span class="line">                    <span class="keyword">if</span> (diffX * diffX + diffY * diffY + diffZ * diffZ &gt; <span class="number">0.05</span>)</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="comment">// 修改标志</span></span><br><span class="line">                    cloudNeighborPicked[ind + l] = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 与上文同理，处理左侧五个相邻点</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> l = <span class="number">-1</span>; l &gt;= <span class="number">-5</span>; l--)</span><br><span class="line">                    <span class="comment">// ......</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 挑选平面点，过程与边缘点同理</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> k = sp; k &lt;= ep; k++)</span><br><span class="line">            <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 最后对该点云中提取的所有surf_less_flat特征点进行降采样，因为点太多了</span></span><br><span class="line">            <span class="comment">// ......</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="laserOdometry"><a href="#laserOdometry" class="headerlink" title="laserOdometry"></a>laserOdometry</h3><p>主要功能：通过前后两帧的点云配准求得两帧之间的位姿变换关系，进而得到当前帧在世界坐标系下的位姿</p>
<p>该节点以点云配准为主，因此所有过程都为求解位姿服务，过程如下：<code>取出待匹配点云</code>，<code>ICP迭代</code>， <code>Ceres求解</code>，<code>更新用于匹配的目标点云</code></p>
<p>第一帧的初始位置的坐标系就是世界坐标系，因此从第二帧开始不断求得当前帧和前一帧间的位姿变换，不断迭代，就能得到每一帧在世界坐标系下的位姿；同时因为处理的是连续帧，即第一帧与第二帧，第二帧与第三帧，…… ，因此得到的位姿也是连续变化的</p>
<p>由于通过前后相邻两帧之间配准，因此速度较快，但误差较大，即<strong>高频率低精度</strong></p>
<p><strong>几个变量说明：</strong></p>
<ol>
<li><p><code>q_w_curr</code> 和 <code>t_w_curr</code> 是想要得到当前帧在世界坐标系下的位姿</p>
</li>
<li><p><code>para_q</code> 和 <code>para_t</code> 是点云匹配是位姿变换的优化变量</p>
</li>
<li><p><code>q_last_curr</code> 和 <code>t_last_curr</code> 是里程计部分优化得到的两帧间位姿变换的结果</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 2 和 3 由于共用内存，因此是相同的，优化 2 就是优化 3</span></span><br><span class="line"><span class="function">Eigen::Map&lt;Eigen::Quaterniond&gt; <span class="title">q_last_curr</span><span class="params">(para_q)</span></span>;</span><br><span class="line"><span class="function">Eigen::Map&lt;Eigen::Vector3d&gt; <span class="title">t_last_curr</span><span class="params">(<span class="type">para_t</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 世界坐标系下的位姿是通过不断迭代求得的</span></span><br><span class="line">t_w_curr = t_w_curr + q_w_curr * t_last_curr;</span><br><span class="line">q_w_curr = q_w_curr * q_last_curr;</span><br></pre></td></tr></table></figure>

<h4 id="取出待匹配点云"><a href="#取出待匹配点云" class="headerlink" title="取出待匹配点云"></a>取出待匹配点云</h4><p>保证从队列中取出的五个点云时间戳相同，即五个点云来自同一帧数据</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!cornerSharpBuf.<span class="built_in">empty</span>() &amp;&amp; !cornerLessSharpBuf.<span class="built_in">empty</span>() &amp;&amp;</span><br><span class="line">            !surfFlatBuf.<span class="built_in">empty</span>() &amp;&amp; !surfLessFlatBuf.<span class="built_in">empty</span>() &amp;&amp;</span><br><span class="line">            !fullPointsBuf.<span class="built_in">empty</span>())  <span class="comment">// 保证所有队列都不为空</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 保证将要取出的五个点云出自同一帧</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 获得五个点云的时间戳</span></span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 保证时间戳相同，即保证五个点云出自同一帧</span></span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取出对应的五个点云</span></span><br><span class="line">    &#123;</span><br><span class="line">        mBuf.<span class="built_in">lock</span>();</span><br><span class="line">        (......).<span class="built_in">pop</span>();</span><br><span class="line">        mBuf.<span class="built_in">unlock</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="ICP-迭代"><a href="#ICP-迭代" class="headerlink" title="ICP 迭代"></a>ICP 迭代</h4><p>ICP迭代就是点云配准的<strong>主过程</strong>，分别对边缘点和平面点进行匹配</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 两次ICP迭代</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> opti_counter = <span class="number">0</span>; opti_counter &lt; <span class="number">2</span>; ++opti_counter)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 设置ceres问题</span></span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找边缘特征的对应关系</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; cornerPointsSharpNum; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 找 2 个满足要求的最近点，构建点到线的残差</span></span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找平面特征的对应关系</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; surfPointsFlatNum; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 找 3 个满足要求的最近点，构建点到面的残差</span></span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Ceres求解</span></span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="边缘点匹配"><a href="#边缘点匹配" class="headerlink" title="边缘点匹配"></a>边缘点匹配</h5><p>使用的是改进后的ICP迭代，通过点到线的距离构建残差</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 边缘点匹配</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; cornerPointsSharpNum; ++i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 将该特征点O_cur 转换至上一帧坐标系下，记为点O</span></span><br><span class="line">    <span class="built_in">TransformToStart</span>(&amp;(cornerPointsSharp-&gt;points[i]), &amp;pointSel);</span><br><span class="line">    <span class="comment">// 在上一帧边缘点(包括极大，次极大边缘点)的KDTree中搜索点O的最近邻点，记为点A</span></span><br><span class="line">    kdtreeCornerLast-&gt;<span class="built_in">nearestKSearch</span>(pointSel, <span class="number">1</span>, pointSearchInd, pointSearchSqDis);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> closestPointInd = <span class="number">-1</span>;  <span class="comment">// 最近点A的索引</span></span><br><span class="line">    minPointInd2 = <span class="number">-1</span>;         <span class="comment">// 最近点B的索引</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 点O与点A的距离平方小于阈值才认为有效</span></span><br><span class="line">    <span class="keyword">if</span> (pointSearchSqDis[<span class="number">0</span>] &lt; DISTANCE_SQ_THRESHOLD)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 记录最近点A的信息</span></span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">        <span class="type">double</span> minPointSqDis2 = DISTANCE_SQ_THRESHOLD;  <span class="comment">// 最近点B的距离平方和</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在相邻扫描线上找第二个最近点B(一个线在某一段中最多有一个边缘点；相邻有上下两条)</span></span><br><span class="line">        <span class="comment">// 沿扫描线增加的方向搜索</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = closestPointInd + <span class="number">1</span>; j &lt; (<span class="type">int</span>)laserCloudCornerLast-&gt;points.<span class="built_in">size</span>(); ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 同一条扫描线则continue</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">int</span>(laserCloudCornerLast-&gt;points[j].intensity) &lt;= closestPointScanID)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 不在附近扫描线上则退出循环</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">int</span>(laserCloudCornerLast-&gt;points[j].intensity) &gt; (closestPointScanID + NEARBY_SCAN))</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">			</span><br><span class="line">            <span class="comment">// 求距离</span></span><br><span class="line">            <span class="type">double</span> pointSqDis = ......(x*x+y*y+z*z)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (pointSqDis &lt; minPointSqDis2)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 找到最近点B</span></span><br><span class="line">                minPointSqDis2 = pointSqDis;</span><br><span class="line">                minPointInd2 = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 同理，沿扫描线减小的方向搜索</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = closestPointInd - <span class="number">1</span>; j &gt;= <span class="number">0</span>; --j)</span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (minPointInd2 &gt;= <span class="number">0</span>) <span class="comment">// 最近点A和B都有效，构建残差项</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 构建三个点O,A,B</span></span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 运动补偿时间 s</span></span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 用点O，A，B构造点到线距离的残差项</span></span><br><span class="line">        ceres::CostFunction *cost_function = LidarEdgeFactor::<span class="built_in">Create</span>(curr_point, last_point_a, last_point_b, s);</span><br><span class="line">        problem.<span class="built_in">AddResidualBlock</span>(cost_function, loss_function, para_q, <span class="type">para_t</span>);</span><br><span class="line">        corner_correspondence++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="平面点匹配"><a href="#平面点匹配" class="headerlink" title="平面点匹配"></a>平面点匹配</h5><p>使用的是改进后的ICP迭代，通过点到面的距离构建残差</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 平面点匹配</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; surfPointsFlatNum; ++i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 与边缘点同理，区别仅在于找A,B,C三个最近点</span></span><br><span class="line">    <span class="comment">// A,B在同一条扫描线，C在点A相邻扫描线</span></span><br><span class="line">    <span class="built_in">TransformToStart</span>(&amp;(surfPointsFlat-&gt;points[i]), &amp;pointSel);</span><br><span class="line">    kdtreeSurfLast-&gt;<span class="built_in">nearestKSearch</span>(pointSel, <span class="number">1</span>, pointSearchInd, pointSearchSqDis);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最近点A,B,C的索引</span></span><br><span class="line">    <span class="type">int</span> closestPointInd = <span class="number">-1</span>, minPointInd2 = <span class="number">-1</span>, minPointInd3 = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (pointSearchSqDis[<span class="number">0</span>] &lt; DISTANCE_SQ_THRESHOLD)</span><br><span class="line">    &#123;</span><br><span class="line">        closestPointInd = pointSearchInd[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 记录最近点A的信息</span></span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 扫描线ID增长方向遍历平面点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = closestPointInd + <span class="number">1</span>; j &lt; (<span class="type">int</span>)laserCloudSurfLast-&gt;points.<span class="built_in">size</span>(); ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 不在附近扫描线，终止循环</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">int</span>(laserCloudSurfLast-&gt;points[j].intensity) &gt; (closestPointScanID + NEARBY_SCAN))</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="type">double</span> pointSqDis = ......;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 同一扫描线找最近点B</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">int</span>(laserCloudSurfLast-&gt;points[j].intensity) &lt;= closestPointScanID &amp;&amp; pointSqDis &lt; minPointSqDis2)</span><br><span class="line">            &#123;</span><br><span class="line">                minPointSqDis2 = pointSqDis;</span><br><span class="line">                minPointInd2 = j;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 相邻扫描线找最近点C</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">int</span>(laserCloudSurfLast-&gt;points[j].intensity) &gt; closestPointScanID &amp;&amp; pointSqDis &lt; minPointSqDis3)</span><br><span class="line">            &#123;</span><br><span class="line">                minPointSqDis3 = pointSqDis;</span><br><span class="line">                minPointInd3 = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 扫描线ID下降方向，与上文同理</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = closestPointInd - <span class="number">1</span>; j &gt;= <span class="number">0</span>; --j)</span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (minPointInd2 &gt;= <span class="number">0</span> &amp;&amp; minPointInd3 &gt;= <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 构造点O,A,B,C</span></span><br><span class="line">            <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 构建残差</span></span><br><span class="line">            ceres::CostFunction *cost_function = LidarPlaneFactor::<span class="built_in">Create</span>(curr_point, last_point_a, last_point_b, last_point_c, s);</span><br><span class="line">            problem.<span class="built_in">AddResidualBlock</span>(cost_function, loss_function, para_q, <span class="type">para_t</span>);</span><br><span class="line">            plane_correspondence++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Ceres求解"><a href="#Ceres求解" class="headerlink" title="Ceres求解"></a>Ceres求解</h4><p>Ceres通过初始化问题，构建鲁棒核函数，传入优化变量和残差项，设定求解方式和迭代次数进行求解</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置ceres问题</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 损失函数，就是鲁棒核函数，0.1代表残差大于0.1的点,则权重降低,小于0.1则认为正常,不做特殊的处理</span></span><br><span class="line">    ceres::LossFunction *loss_function = <span class="keyword">new</span> ceres::<span class="built_in">HuberLoss</span>(<span class="number">0.1</span>); </span><br><span class="line">    <span class="comment">// 本地参数，对于SLAM，常用四元数</span></span><br><span class="line">    ceres::LocalParameterization *q_parameterization =</span><br><span class="line">        <span class="keyword">new</span> ceres::<span class="built_in">EigenQuaternionParameterization</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// problem类就是代表具有双边约束的最小二乘问题</span></span><br><span class="line">    <span class="comment">// 为了创建一个最小二乘问题,需要使用</span></span><br><span class="line">    <span class="comment">// Problem::AddResidalBlock() 添加残差模块</span></span><br><span class="line">    <span class="comment">// Problem::AddParameterBlock() 添加参数模块</span></span><br><span class="line">    ceres::Problem::Options problem_options;                   <span class="comment">// 先定义</span></span><br><span class="line">    <span class="function">ceres::Problem <span class="title">problem</span><span class="params">(problem_options)</span></span>;                   <span class="comment">// 再初始化</span></span><br><span class="line">    problem.<span class="built_in">AddParameterBlock</span>(para_q, <span class="number">4</span>, q_parameterization);  <span class="comment">// 添加四元数的参数块</span></span><br><span class="line">    problem.<span class="built_in">AddParameterBlock</span>(<span class="type">para_t</span>, <span class="number">3</span>);                      <span class="comment">// 添加平移的参数块</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 传入残差项</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 边缘点：用点O，A，B构造点到线距离的残差项(只列出一次过程，实际是ICP迭代过程循环传入)</span></span><br><span class="line">    ceres::CostFunction *cost_function = LidarEdgeFactor::<span class="built_in">Create</span>(curr_point, last_point_a, last_point_b, s);</span><br><span class="line">    problem.<span class="built_in">AddResidualBlock</span>(cost_function, loss_function, para_q, <span class="type">para_t</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 平面点：用点O，A，B，C构造点到面距离的残差项(同理，只列出一次过程)</span></span><br><span class="line">    ceres::CostFunction *cost_function = LidarPlaneFactor::<span class="built_in">Create</span>(curr_point, last_point_a, last_point_b, last_point_c, s);</span><br><span class="line">    problem.<span class="built_in">AddResidualBlock</span>(cost_function, loss_function, para_q, <span class="type">para_t</span>);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Ceres求解</span></span><br><span class="line">&#123;</span><br><span class="line">    ceres::Solver::Options options;</span><br><span class="line">    options.linear_solver_type = ceres::DENSE_QR;  <span class="comment">// 配置增量方程的解法</span></span><br><span class="line">    options.max_num_iterations = <span class="number">4</span>;  <span class="comment">// 最大迭代次数</span></span><br><span class="line">    options.minimizer_progress_to_stdout = <span class="literal">false</span>;  <span class="comment">// 优化过程是否输出到终端</span></span><br><span class="line">    ceres::Solver::Summary summary;  <span class="comment">// 优化信息</span></span><br><span class="line">    ceres::<span class="built_in">Solve</span>(options, &amp;problem, &amp;summary);  <span class="comment">// 求解</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="更新用于匹配的目标点云"><a href="#更新用于匹配的目标点云" class="headerlink" title="更新用于匹配的目标点云"></a>更新用于匹配的目标点云</h4><p>该步骤的主要目的是更新KDTree，用于下一帧找最近点</p>
<p>对于第一帧来说，不需要进行匹配，直接将边缘点点云和平面点点云放入目标点云即可，构建KDTree，用于下一帧匹配；</p>
<p>对于第一帧之后的帧，每次处理完后，将当前帧边缘点和平面点点云放入目标点云，构建KDTree，用于下一帧匹配；</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 更新相应数据，为下一次匹配做准备</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 用 cornerPointsLessSharp 更新 laserCloudCornerLast</span></span><br><span class="line">    pcl::PointCloud&lt;PointType&gt;::Ptr laserCloudTemp = cornerPointsLessSharp;</span><br><span class="line">    cornerPointsLessSharp = laserCloudCornerLast;</span><br><span class="line">    laserCloudCornerLast = laserCloudTemp;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用 surfPointsLessFlat 更新 laserCloudSurfLast</span></span><br><span class="line">    laserCloudTemp = surfPointsLessFlat;</span><br><span class="line">    surfPointsLessFlat = laserCloudSurfLast;</span><br><span class="line">    laserCloudSurfLast = laserCloudTemp;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新相应的KDTree，为下一次点云特征匹配提供target</span></span><br><span class="line">    laserCloudCornerLastNum = laserCloudCornerLast-&gt;points.<span class="built_in">size</span>();</span><br><span class="line">    laserCloudSurfLastNum = laserCloudSurfLast-&gt;points.<span class="built_in">size</span>();</span><br><span class="line">    kdtreeCornerLast-&gt;<span class="built_in">setInputCloud</span>(laserCloudCornerLast);</span><br><span class="line">    kdtreeSurfLast-&gt;<span class="built_in">setInputCloud</span>(laserCloudSurfLast);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="laserMapping"><a href="#laserMapping" class="headerlink" title="laserMapping"></a>laserMapping</h3><p>主要功能：通过当前帧与子图之间进行点云配准求得当前帧在世界坐标系下的位姿</p>
<p>该节点主要进行点云精配准，即前文所说的当前帧和子图之间配准，过程如下：<code>Buffer预处理</code> ，<code>地图预处理</code>，<code>提取局部地图</code>，<code>ICP迭代</code>，<code>Ceres求解</code>，<code>更新位姿和地图</code></p>
<p>与前端里程计不同，laserMapping节点接收到的点云数据不是连续的，而是由前端里程计对频率进行控制，由参数<code>skipFrameNum</code> 的值进行控制；例如设置 <code>skipFrameNum = 2</code> ，则前端里程计每处理两帧，才将最新的一帧发出去，同时由于后端优化时间较长，会将来不及处理的帧直接丢弃，因此后端优化得到的位姿是离散的</p>
<p>由于是当前帧和子图进行配准，因此速度较慢，误差相比里程计更小，即<strong>低频率高精度</strong></p>
<p><strong>变量说明：</strong></p>
<ol>
<li><code>q_w_curr</code> 和 <code>t_w_curr</code> 是 Mapping 线程估计的当前帧在世界坐标系下的位姿</li>
<li><code>q_wodom_curr</code> 和 <code>t_wodom_curr</code> 是里程计估计的当前帧在世界坐标系下的位姿</li>
<li><code>q_wmap_wodom</code> 和 <code>t_wmap_wodom</code> 是世界坐标系下里程计估计的位姿与 Mapping 估计的位姿间的增量</li>
</ol>
<p>后端优化过程比较耗时，为了保证算法实时性，有两个<strong>特殊处理</strong></p>
<ol>
<li>Buffer预处理时，以最旧一帧边缘点为标准，取出后将队列清空，保证每次处理的都是最新的数据</li>
<li>接收里程计估计的位姿时，将上一次得到的增量与其相乘，作为Mapping估计的位姿直接发布，后续再更新</li>
</ol>
<h4 id="Buffer预处理"><a href="#Buffer预处理" class="headerlink" title="Buffer预处理"></a>Buffer预处理</h4><p>与上一节里程计相同，对取出点云的时间戳进行判定，保证取出的点云属于同一帧</p>
<p>同时按照上文说的特殊处理，将边缘点队列清空</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Buffer预处理</span></span><br><span class="line"><span class="keyword">while</span>(<span class="comment">// 所有队列不为空)</span></span><br><span class="line">&#123;</span><br><span class="line">	mBuf.<span class="built_in">lock</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(<span class="comment">// 时间戳小于边缘点点云)</span></span><br><span class="line">    	(......).pop;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(<span class="comment">// 时间戳不同)</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 从队列中取出并存储 边缘点、平面点、所有点点云 以及 里程计估计的位姿</span></span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 清空边缘点队列</span></span><br><span class="line">    <span class="keyword">while</span>(!cornerLastBuf.<span class="built_in">empty</span>())</span><br><span class="line">    	cornerLastBuf.<span class="built_in">pop</span>();</span><br><span class="line">    </span><br><span class="line">    mBuf.<span class="built_in">unlock</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="地图预处理"><a href="#地图预处理" class="headerlink" title="地图预处理"></a>地图预处理</h4><p>全局地图划分栅格，分辨率为50，即每个格的边对应现实世界50m，共划分为21×21×11的三维栅格，子图为5×5×3的局部栅格地图，如下图左侧所示，后文采用简化版(图中右侧)进行分析</p>
<p><img src="/2022/09/26/20220926/%E6%A0%85%E6%A0%BC%E5%9C%B0%E5%9B%BE.png" alt="栅格地图"></p>
<p>栅格地图需要进行维护，即每次找到当前帧在世界坐标系下的位姿所处的栅格，周围留出足够的空间用于存放周围点云，如果所处栅格在栅格地图边缘，则对地图进行移动以满足条件；具体为保证位姿所处的栅格范围在I,J,K方向上分别满足3-18，3-18，3-8，若不满足则移动整体地图，直到满足条件(下图以在I方向上 &gt; 18 为例进行地图维护)</p>
<p><img src="/2022/09/26/20220926/%E5%9C%B0%E5%9B%BE%E7%BB%B4%E6%8A%A4.png" alt="地图维护"></p>
<p>在代码上表现为 6 个 while 循环</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计算当前位姿在全局三维栅格中存放的位置（索引），栅格分辨率为 50 </span></span><br><span class="line"><span class="comment">// + 25.0 起四舍五入的作用，([0, 25) 取 0, [25, 50&#125; 进一)</span></span><br><span class="line"><span class="type">int</span> centerCubeI = <span class="built_in">int</span>((t_w_curr.<span class="built_in">x</span>() + <span class="number">25.0</span>) / <span class="number">50.0</span>) + laserCloudCenWidth;</span><br><span class="line"><span class="type">int</span> centerCubeJ = <span class="built_in">int</span>((t_w_curr.<span class="built_in">y</span>() + <span class="number">25.0</span>) / <span class="number">50.0</span>) + laserCloudCenHeight;</span><br><span class="line"><span class="type">int</span> centerCubeK = <span class="built_in">int</span>((t_w_curr.<span class="built_in">z</span>() + <span class="number">25.0</span>) / <span class="number">50.0</span>) + laserCloudCenDepth;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对负数的情况做出调整，保证 (-1, -1 , -1) 不会和 (0, 0, 0) 存在同一位置</span></span><br><span class="line"><span class="keyword">if</span> (t_w_curr.<span class="built_in">x</span>() + <span class="number">25.0</span> &lt; <span class="number">0</span>)</span><br><span class="line">    centerCubeI--;</span><br><span class="line"><span class="keyword">if</span> (t_w_curr.<span class="built_in">y</span>() + <span class="number">25.0</span> &lt; <span class="number">0</span>)</span><br><span class="line">    centerCubeJ--;</span><br><span class="line"><span class="keyword">if</span> (t_w_curr.<span class="built_in">z</span>() + <span class="number">25.0</span> &lt; <span class="number">0</span>)</span><br><span class="line">    centerCubeK--;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面 6 个循环分别对6种不满足条件的情况进行地图维护</span></span><br><span class="line"><span class="comment">// 对宽度方向小于要求进行维护</span></span><br><span class="line"><span class="keyword">while</span> (centerCubeI &lt; <span class="number">3</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 过程类似于数组元素的移动，只需要注意索引即可</span></span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">    </span><br><span class="line">    centerCubeI++;</span><br><span class="line">    <span class="comment">// 在移动完点云后，需要将原点对应的栅格坐标也向宽度正方向移动一个单位，保证栅格坐标计算的正确性</span></span><br><span class="line">    laserCloudCenWidth++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 对栅格宽度方向进行一样的操作</span></span><br><span class="line"><span class="keyword">while</span> (centerCubeI &gt;= laserCloudWidth - <span class="number">3</span>) </span><br><span class="line"><span class="comment">// 对栅格高度方向进行一样的操作</span></span><br><span class="line"><span class="keyword">while</span> (centerCubeJ &lt; <span class="number">3</span>)</span><br><span class="line"><span class="comment">// 对栅格高度方向进行一样的操作</span></span><br><span class="line"><span class="keyword">while</span> (centerCubeJ &gt;= laserCloudHeight - <span class="number">3</span>)</span><br><span class="line"><span class="comment">// 对栅格深度方向进行一样的操作</span></span><br><span class="line"><span class="keyword">while</span> (centerCubeK &lt; <span class="number">3</span>)</span><br><span class="line"><span class="comment">// 对栅格深度方向进行一样的操作</span></span><br><span class="line"><span class="keyword">while</span> (centerCubeK &gt;= laserCloudDepth - <span class="number">3</span>)</span><br></pre></td></tr></table></figure>

<h4 id="提取局部地图"><a href="#提取局部地图" class="headerlink" title="提取局部地图"></a>提取局部地图</h4><p>局部地图，即上图中的绿色部分，提取出来并构建 KDTree ，用于后续与当前帧的匹配</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取当前位置周围的点云作为匹配对象</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = centerCubeI - <span class="number">2</span>; i &lt;= centerCubeI + <span class="number">2</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = centerCubeJ - <span class="number">2</span>; j &lt;= centerCubeJ + <span class="number">2</span>; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> k = centerCubeK - <span class="number">1</span>; k &lt;= centerCubeK + <span class="number">1</span>; k++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= <span class="number">0</span> &amp;&amp; i &lt; laserCloudWidth &amp;&amp;</span><br><span class="line">                j &gt;= <span class="number">0</span> &amp;&amp; j &lt; laserCloudHeight &amp;&amp;</span><br><span class="line">                k &gt;= <span class="number">0</span> &amp;&amp; k &lt; laserCloudDepth)</span><br><span class="line">            &#123; </span><br><span class="line">                laserCloudValidInd[laserCloudValidNum] = i + laserCloudWidth * j + laserCloudWidth * laserCloudHeight * k;</span><br><span class="line">                laserCloudValidNum++;</span><br><span class="line">                laserCloudSurroundInd[laserCloudSurroundNum] = i + laserCloudWidth * j + laserCloudWidth * laserCloudHeight * k;</span><br><span class="line">                laserCloudSurroundNum++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 提取局部地图点云（当前载体附近的点云）</span></span><br><span class="line">laserCloudCornerFromMap-&gt;<span class="built_in">clear</span>();</span><br><span class="line">laserCloudSurfFromMap-&gt;<span class="built_in">clear</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; laserCloudValidNum; i++)</span><br><span class="line">&#123;</span><br><span class="line">    *laserCloudCornerFromMap += *laserCloudCornerArray[laserCloudValidInd[i]];</span><br><span class="line">    *laserCloudSurfFromMap += *laserCloudSurfArray[laserCloudValidInd[i]];</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> laserCloudCornerFromMapNum = laserCloudCornerFromMap-&gt;points.<span class="built_in">size</span>();</span><br><span class="line"><span class="type">int</span> laserCloudSurfFromMapNum = laserCloudSurfFromMap-&gt;points.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对待处理的边缘点点云进行降采样处理</span></span><br><span class="line">pcl::PointCloud&lt;PointType&gt;::<span class="function">Ptr <span class="title">laserCloudCornerStack</span><span class="params">(<span class="keyword">new</span> pcl::PointCloud&lt;PointType&gt;())</span></span>;</span><br><span class="line">downSizeFilterCorner.<span class="built_in">setInputCloud</span>(laserCloudCornerLast);</span><br><span class="line">downSizeFilterCorner.<span class="built_in">filter</span>(*laserCloudCornerStack);</span><br><span class="line"><span class="type">int</span> laserCloudCornerStackNum = laserCloudCornerStack-&gt;points.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对待处理的平面点云进行降采样处理</span></span><br><span class="line">pcl::PointCloud&lt;PointType&gt;::<span class="function">Ptr <span class="title">laserCloudSurfStack</span><span class="params">(<span class="keyword">new</span> pcl::PointCloud&lt;PointType&gt;())</span></span>;</span><br><span class="line">downSizeFilterSurf.<span class="built_in">setInputCloud</span>(laserCloudSurfLast);</span><br><span class="line">downSizeFilterSurf.<span class="built_in">filter</span>(*laserCloudSurfStack);</span><br><span class="line"><span class="type">int</span> laserCloudSurfStackNum = laserCloudSurfStack-&gt;points.<span class="built_in">size</span>();</span><br></pre></td></tr></table></figure>

<h4 id="ICP迭代"><a href="#ICP迭代" class="headerlink" title="ICP迭代"></a>ICP迭代</h4><p>与前端里程计基本一致，区别在于：</p>
<ol>
<li>匹配使用的点云不同(里程计是极大和次极大匹配；Mapping 是次极大和次极大匹配)</li>
<li>构建残差的方式不同(里程计是两点建线，三点建面；Mapping 是特征向量建线，法向量建面)</li>
<li>坐标系不同(里程计匹配的点坐标系与待匹配的点在各自坐标系下；Mapping 则均为世界坐标系)</li>
</ol>
<h5 id="边缘点匹配-1"><a href="#边缘点匹配-1" class="headerlink" title="边缘点匹配"></a>边缘点匹配</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 边缘点匹配，构建残差</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; laserCloudCornerStackNum; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 获取原始点并将其坐标转换至全局坐标系，在角点 KD 树搜索最近的 5 个点</span></span><br><span class="line">    pointOri = laserCloudCornerStack-&gt;points[i];</span><br><span class="line">    <span class="comment">// 需要注意的是submap中的点云都是world坐标系，而当前帧的点云都是Lidar坐标系，所以</span></span><br><span class="line">    <span class="comment">// 在搜寻最近邻点时，先用预测的Mapping位姿w_curr，将Lidar坐标系下的特征点变换到world坐标系下</span></span><br><span class="line">    <span class="built_in">pointAssociateToMap</span>(&amp;pointOri, &amp;pointSel);</span><br><span class="line">    kdtreeCornerFromMap-&gt;<span class="built_in">nearestKSearch</span>(pointSel, <span class="number">5</span>, pointSearchInd, pointSearchSqDis); </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当搜索到的 5 个点都在当前选择点的 1m 范围内，才进行以下操作</span></span><br><span class="line">    <span class="keyword">if</span> (pointSearchSqDis[<span class="number">4</span>] &lt; <span class="number">1.0</span>)</span><br><span class="line">    &#123; </span><br><span class="line">        <span class="comment">// 获取这 5 个点的位置并计算其平均值作为线段中心</span></span><br><span class="line">        std::vector&lt;Eigen::Vector3d&gt; nearCorners;</span><br><span class="line">        <span class="function">Eigen::Vector3d <span class="title">center</span><span class="params">(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">5</span>; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function">Eigen::Vector3d <span class="title">tmp</span><span class="params">(laserCloudCornerFromMap-&gt;points[pointSearchInd[j]].x,</span></span></span><br><span class="line"><span class="params"><span class="function">                                laserCloudCornerFromMap-&gt;points[pointSearchInd[j]].y,</span></span></span><br><span class="line"><span class="params"><span class="function">                                laserCloudCornerFromMap-&gt;points[pointSearchInd[j]].z)</span></span>;</span><br><span class="line">            center = center + tmp;</span><br><span class="line">            nearCorners.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 计算这个5个最近邻点的中心</span></span><br><span class="line">        center = center / <span class="number">5.0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据距离设置这 5 个点的协方差矩阵 cov = sum(mean * mean^T)</span></span><br><span class="line">        Eigen::Matrix3d covMat = Eigen::Matrix3d::<span class="built_in">Zero</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">5</span>; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            Eigen::Matrix&lt;<span class="type">double</span>, <span class="number">3</span>, <span class="number">1</span>&gt; tmpZeroMean = nearCorners[j] - center;</span><br><span class="line">            covMat = covMat + tmpZeroMean * tmpZeroMean.<span class="built_in">transpose</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算协方差矩阵的特征值和特征向量，用于判断这5个点是不是呈线状分布，此为PCA的原理</span></span><br><span class="line">        <span class="function">Eigen::SelfAdjointEigenSolver&lt;Eigen::Matrix3d&gt; <span class="title">saes</span><span class="params">(covMat)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果是这 5 个点来至同一个线特征(5个点呈线状分布)，那么最大的特征值会比另外两个都大很多，</span></span><br><span class="line">        <span class="comment">// 并且其相应的特征向量表明该直线的方向，这里用 3 倍大小作为衡量标准</span></span><br><span class="line">        Eigen::Vector3d unit_direction = saes.<span class="built_in">eigenvectors</span>().<span class="built_in">col</span>(<span class="number">2</span>);</span><br><span class="line">        <span class="function">Eigen::Vector3d <span class="title">curr_point</span><span class="params">(pointOri.x, pointOri.y, pointOri.z)</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (saes.<span class="built_in">eigenvalues</span>()[<span class="number">2</span>] &gt; <span class="number">3</span> * saes.<span class="built_in">eigenvalues</span>()[<span class="number">1</span>])</span><br><span class="line">        &#123; </span><br><span class="line">            <span class="comment">// 从中心点沿着方向向量向两端移动0.1m，构造线上的两个点</span></span><br><span class="line">            Eigen::Vector3d point_on_line = center;</span><br><span class="line">            Eigen::Vector3d point_a, point_b;</span><br><span class="line">            point_a = <span class="number">0.1</span> * unit_direction + point_on_line;</span><br><span class="line">            point_b = <span class="number">-0.1</span> * unit_direction + point_on_line;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将两个点以及当前角点（注意是在点云中的，坐标是在载体坐标系下表示）传入 ceres 中构建残差</span></span><br><span class="line">            ceres::CostFunction *cost_function = LidarEdgeFactor::<span class="built_in">Create</span>(curr_point, point_a, point_b, <span class="number">1.0</span>);</span><br><span class="line">            problem.<span class="built_in">AddResidualBlock</span>(cost_function, loss_function, parameters, parameters + <span class="number">4</span>);</span><br><span class="line">            corner_num++;	</span><br><span class="line">        &#125;							</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="平面点匹配-1"><a href="#平面点匹配-1" class="headerlink" title="平面点匹配"></a>平面点匹配</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 平面点匹配，构建残差</span></span><br><span class="line"><span class="type">int</span> surf_num = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; laserCloudSurfStackNum; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 获取原始点并将其坐标转换至全局坐标系，在平面点的 KD 树搜索最近的 5 个点</span></span><br><span class="line">    pointOri = laserCloudSurfStack-&gt;points[i];</span><br><span class="line">    <span class="built_in">pointAssociateToMap</span>(&amp;pointOri, &amp;pointSel);</span><br><span class="line">    kdtreeSurfFromMap-&gt;<span class="built_in">nearestKSearch</span>(pointSel, <span class="number">5</span>, pointSearchInd, pointSearchSqDis);</span><br><span class="line"></span><br><span class="line">    Eigen::Matrix&lt;<span class="type">double</span>, <span class="number">5</span>, <span class="number">3</span>&gt; matA0;</span><br><span class="line">    Eigen::Matrix&lt;<span class="type">double</span>, <span class="number">5</span>, <span class="number">1</span>&gt; matB0 = <span class="number">-1</span> * Eigen::Matrix&lt;<span class="type">double</span>, <span class="number">5</span>, <span class="number">1</span>&gt;::<span class="built_in">Ones</span>();</span><br><span class="line">    <span class="comment">// 当搜索到的 5 个点都在当前选择点的 1m 范围内，才进行以下操作</span></span><br><span class="line">    <span class="keyword">if</span> (pointSearchSqDis[<span class="number">4</span>] &lt; <span class="number">1.0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 将 5 个点按列插入 5x3 矩阵中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">5</span>; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">matA0</span>(j, <span class="number">0</span>) = laserCloudSurfFromMap-&gt;points[pointSearchInd[j]].x;</span><br><span class="line">            <span class="built_in">matA0</span>(j, <span class="number">1</span>) = laserCloudSurfFromMap-&gt;points[pointSearchInd[j]].y;</span><br><span class="line">            <span class="built_in">matA0</span>(j, <span class="number">2</span>) = laserCloudSurfFromMap-&gt;points[pointSearchInd[j]].z;</span><br><span class="line">            <span class="comment">//printf(&quot; pts %f %f %f &quot;, matA0(j, 0), matA0(j, 1), matA0(j, 2));</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 计算平面法向量，平面方程为 Ax + By + Cz = -1，代入 5 个点，利用最小二乘法解出参数即可得到法向量</span></span><br><span class="line">        Eigen::Vector3d norm = matA0.<span class="built_in">colPivHouseholderQr</span>().<span class="built_in">solve</span>(matB0);</span><br><span class="line">        <span class="comment">// Ax + By + Cz + 1 = 0，全部除以法向量的模长，方程依旧成立，而且使得法向量归一化了</span></span><br><span class="line">        <span class="type">double</span> negative_OA_dot_norm = <span class="number">1</span> / norm.<span class="built_in">norm</span>();</span><br><span class="line">        norm.<span class="built_in">normalize</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过计算每个点到平面的距离来判断平面拟合的效果，距离公式为：d = |Ax + By + Cz + D|/sqrt(A^2+B^2+C^2)</span></span><br><span class="line">        <span class="comment">// 归一化后平面公式为：Ax + By + Cz + D = 0, D = 1/sqrt(A&#x27;^2+B&#x27;^2+C&#x27;^2)</span></span><br><span class="line">        <span class="comment">// 因此，计算公式为：d = Ax + By + Cz + negative_OA_dot_norm</span></span><br><span class="line">        <span class="type">bool</span> planeValid = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">5</span>; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// if OX * n &gt; 0.2, then plane is not fit well</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">fabs</span>(<span class="built_in">norm</span>(<span class="number">0</span>) * laserCloudSurfFromMap-&gt;points[pointSearchInd[j]].x +</span><br><span class="line">                     <span class="built_in">norm</span>(<span class="number">1</span>) * laserCloudSurfFromMap-&gt;points[pointSearchInd[j]].y +</span><br><span class="line">                     <span class="built_in">norm</span>(<span class="number">2</span>) * laserCloudSurfFromMap-&gt;points[pointSearchInd[j]].z + negative_OA_dot_norm) &gt; <span class="number">0.2</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                planeValid = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">Eigen::Vector3d <span class="title">curr_point</span><span class="params">(pointOri.x, pointOri.y, pointOri.z)</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (planeValid)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 将选择的点和法向量传入 ceres 中构建残差块</span></span><br><span class="line">            ceres::CostFunction *cost_function = LidarPlaneNormFactor::<span class="built_in">Create</span>(curr_point, norm, negative_OA_dot_norm);</span><br><span class="line">            problem.<span class="built_in">AddResidualBlock</span>(cost_function, loss_function, parameters, parameters + <span class="number">4</span>);</span><br><span class="line">            surf_num++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Ceres求解-1"><a href="#Ceres求解-1" class="headerlink" title="Ceres求解"></a>Ceres求解</h4><p>与里程计基本相同，都是通过设置Ceres问题，传入参数及优化变量进行求解，区别是残差项的构造不同</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构建Ceres问题</span></span><br><span class="line">&#123;</span><br><span class="line">    ceres::LossFunction *loss_function = <span class="keyword">new</span> ceres::<span class="built_in">HuberLoss</span>(<span class="number">0.1</span>);  <span class="comment">// 损失函数</span></span><br><span class="line">    ceres::LocalParameterization *q_parameterization =</span><br><span class="line">        <span class="keyword">new</span> ceres::<span class="built_in">EigenQuaternionParameterization</span>();  <span class="comment">// 本地参数</span></span><br><span class="line">    ceres::Problem::Options problem_options;</span><br><span class="line"></span><br><span class="line">    <span class="function">ceres::Problem <span class="title">problem</span><span class="params">(problem_options)</span></span>;</span><br><span class="line">    problem.<span class="built_in">AddParameterBlock</span>(parameters, <span class="number">4</span>, q_parameterization);  <span class="comment">// 添加四元数参数快</span></span><br><span class="line">    problem.<span class="built_in">AddParameterBlock</span>(parameters + <span class="number">4</span>, <span class="number">3</span>);  <span class="comment">// 添加平移向量参数快</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 传入残差项(实际是在ICP迭代过程中循环传入)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 边缘点：用点O及构造的A,B构建残差项(注意是在点云中的，坐标是在载体坐标系下表示)</span></span><br><span class="line">    ceres::CostFunction *cost_function = LidarEdgeFactor::<span class="built_in">Create</span>(curr_point, point_a, point_b, <span class="number">1.0</span>);</span><br><span class="line">    problem.<span class="built_in">AddResidualBlock</span>(cost_function, loss_function, parameters, parameters + <span class="number">4</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 平面点：用点O及拟合平面的法向量构建残差项</span></span><br><span class="line">    ceres::CostFunction *cost_function = LidarPlaneNormFactor::<span class="built_in">Create</span>(curr_point, norm, negative_OA_dot_norm);</span><br><span class="line">    problem.<span class="built_in">AddResidualBlock</span>(cost_function, loss_function, parameters, parameters + <span class="number">4</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Ceres求解</span></span><br><span class="line">&#123;</span><br><span class="line">    TicToc t_solver;</span><br><span class="line">    ceres::Solver::Options options;</span><br><span class="line">    options.linear_solver_type = ceres::DENSE_QR;  <span class="comment">// 配置增量方程的解法</span></span><br><span class="line">    options.max_num_iterations = <span class="number">4</span>;  <span class="comment">// 最大迭代次数</span></span><br><span class="line">    options.minimizer_progress_to_stdout = <span class="literal">false</span>;  <span class="comment">// 优化过程是否输出到终端</span></span><br><span class="line">    options.check_gradients = <span class="literal">false</span>;  <span class="comment">// 检查优化是否失败，如果设置为true比较耗费性能，一般保持默认</span></span><br><span class="line">    options.gradient_check_relative_precision = <span class="number">1e-4</span>;  <span class="comment">// 在gradient checker中检查的精度</span></span><br><span class="line">    ceres::Solver::Summary summary;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="更新位姿和地图"><a href="#更新位姿和地图" class="headerlink" title="更新位姿和地图"></a>更新位姿和地图</h4><p>更新前端里程计估计与Mapping之间估计的增量，同时将点云转换到世界坐标系下并插入到栅格中</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">transformUpdate</span>(); <span class="comment">// 利用优化后的全局位姿，更新相对于里程计位姿的转换（修正量）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对当前新加入的边缘点点云中的所有点，进行坐标转换至世界坐标系下，找到其对应的点云栅格坐标</span></span><br><span class="line"><span class="comment">// 插入到该栅格中存放的点云中</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; laserCloudCornerStackNum; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 转换到世界坐标系下</span></span><br><span class="line">    <span class="built_in">pointAssociateToMap</span>(&amp;laserCloudCornerStack-&gt;points[i], &amp;pointSel);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> cubeI = <span class="built_in">int</span>((pointSel.x + <span class="number">25.0</span>) / <span class="number">50.0</span>) + laserCloudCenWidth;</span><br><span class="line">    <span class="type">int</span> cubeJ = <span class="built_in">int</span>((pointSel.y + <span class="number">25.0</span>) / <span class="number">50.0</span>) + laserCloudCenHeight;</span><br><span class="line">    <span class="type">int</span> cubeK = <span class="built_in">int</span>((pointSel.z + <span class="number">25.0</span>) / <span class="number">50.0</span>) + laserCloudCenDepth;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pointSel.x + <span class="number">25.0</span> &lt; <span class="number">0</span>)</span><br><span class="line">    	cubeI--;</span><br><span class="line">    <span class="keyword">if</span> (pointSel.y + <span class="number">25.0</span> &lt; <span class="number">0</span>)</span><br><span class="line">    	cubeJ--;</span><br><span class="line">    <span class="keyword">if</span> (pointSel.z + <span class="number">25.0</span> &lt; <span class="number">0</span>)</span><br><span class="line">    	cubeK--;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cubeI &gt;= <span class="number">0</span> &amp;&amp; cubeI &lt; laserCloudWidth &amp;&amp;</span><br><span class="line">    	cubeJ &gt;= <span class="number">0</span> &amp;&amp; cubeJ &lt; laserCloudHeight &amp;&amp;</span><br><span class="line">    	cubeK &gt;= <span class="number">0</span> &amp;&amp; cubeK &lt; laserCloudDepth)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> cubeInd = cubeI + laserCloudWidth * cubeJ + laserCloudWidth * laserCloudHeight * cubeK;</span><br><span class="line">        laserCloudCornerArray[cubeInd]-&gt;<span class="built_in">push_back</span>(pointSel);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 同理，对平面点云进行处理</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; laserCloudSurfStackNum; i++)</span><br><span class="line"><span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对这次处理涉及到的点云进行降采样处理</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; laserCloudValidNum; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ind = laserCloudValidInd[i];</span><br><span class="line"></span><br><span class="line">    pcl::PointCloud&lt;PointType&gt;::<span class="function">Ptr <span class="title">tmpCorner</span><span class="params">(<span class="keyword">new</span> pcl::PointCloud&lt;PointType&gt;())</span></span>;</span><br><span class="line">    downSizeFilterCorner.<span class="built_in">setInputCloud</span>(laserCloudCornerArray[ind]);</span><br><span class="line">    downSizeFilterCorner.<span class="built_in">filter</span>(*tmpCorner);</span><br><span class="line">    laserCloudCornerArray[ind] = tmpCorner;</span><br><span class="line"></span><br><span class="line">    pcl::PointCloud&lt;PointType&gt;::<span class="function">Ptr <span class="title">tmpSurf</span><span class="params">(<span class="keyword">new</span> pcl::PointCloud&lt;PointType&gt;())</span></span>;</span><br><span class="line">    downSizeFilterSurf.<span class="built_in">setInputCloud</span>(laserCloudSurfArray[ind]);</span><br><span class="line">    downSizeFilterSurf.<span class="built_in">filter</span>(*tmpSurf);</span><br><span class="line">    laserCloudSurfArray[ind] = tmpSurf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://lmay001.github.io">LMay</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://lmay001.github.io/2022/09/26/20220926/">http://lmay001.github.io/2022/09/26/20220926/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://lmay001.github.io" target="_blank">LMay</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/SLAM/">SLAM</a><a class="post-meta__tags" href="/tags/A-LOAM/">A-LOAM</a><a class="post-meta__tags" href="/tags/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/">算法分析</a></div><div class="post_share"><div class="social-share" data-image="https://tucang.cc/api/image/show/179aa07d6ac831122962767409dea79b" data-sites="facebook,twitter,wechat,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#A-LOAM%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90"><span class="toc-number">1.</span> <span class="toc-text">A-LOAM算法分析</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF%E5%88%86%E6%9E%90"><span class="toc-number">1.1.</span> <span class="toc-text">思路分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90"><span class="toc-number">1.2.</span> <span class="toc-text">流程分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-number">1.3.</span> <span class="toc-text">代码分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#scanRegistration"><span class="toc-number">1.3.1.</span> <span class="toc-text">scanRegistration</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E9%A2%84%E5%A4%84%E7%90%86"><span class="toc-number">1.3.1.1.</span> <span class="toc-text">数据预处理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E6%89%AB%E6%8F%8F%E7%BA%BF%E4%B8%8E%E8%BF%90%E5%8A%A8%E8%A1%A5%E5%81%BF%E6%97%B6%E9%97%B4"><span class="toc-number">1.3.1.2.</span> <span class="toc-text">计算扫描线与运动补偿时间</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E6%9B%B2%E7%8E%87"><span class="toc-number">1.3.1.3.</span> <span class="toc-text">计算曲率</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8F%90%E5%8F%96%E7%89%B9%E5%BE%81%E7%82%B9"><span class="toc-number">1.3.1.4.</span> <span class="toc-text">提取特征点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#laserOdometry"><span class="toc-number">1.3.2.</span> <span class="toc-text">laserOdometry</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%96%E5%87%BA%E5%BE%85%E5%8C%B9%E9%85%8D%E7%82%B9%E4%BA%91"><span class="toc-number">1.3.2.1.</span> <span class="toc-text">取出待匹配点云</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ICP-%E8%BF%AD%E4%BB%A3"><span class="toc-number">1.3.2.2.</span> <span class="toc-text">ICP 迭代</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BE%B9%E7%BC%98%E7%82%B9%E5%8C%B9%E9%85%8D"><span class="toc-number">1.3.2.2.1.</span> <span class="toc-text">边缘点匹配</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B9%B3%E9%9D%A2%E7%82%B9%E5%8C%B9%E9%85%8D"><span class="toc-number">1.3.2.2.2.</span> <span class="toc-text">平面点匹配</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Ceres%E6%B1%82%E8%A7%A3"><span class="toc-number">1.3.2.3.</span> <span class="toc-text">Ceres求解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9B%B4%E6%96%B0%E7%94%A8%E4%BA%8E%E5%8C%B9%E9%85%8D%E7%9A%84%E7%9B%AE%E6%A0%87%E7%82%B9%E4%BA%91"><span class="toc-number">1.3.2.4.</span> <span class="toc-text">更新用于匹配的目标点云</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#laserMapping"><span class="toc-number">1.3.3.</span> <span class="toc-text">laserMapping</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Buffer%E9%A2%84%E5%A4%84%E7%90%86"><span class="toc-number">1.3.3.1.</span> <span class="toc-text">Buffer预处理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%B0%E5%9B%BE%E9%A2%84%E5%A4%84%E7%90%86"><span class="toc-number">1.3.3.2.</span> <span class="toc-text">地图预处理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8F%90%E5%8F%96%E5%B1%80%E9%83%A8%E5%9C%B0%E5%9B%BE"><span class="toc-number">1.3.3.3.</span> <span class="toc-text">提取局部地图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ICP%E8%BF%AD%E4%BB%A3"><span class="toc-number">1.3.3.4.</span> <span class="toc-text">ICP迭代</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BE%B9%E7%BC%98%E7%82%B9%E5%8C%B9%E9%85%8D-1"><span class="toc-number">1.3.3.4.1.</span> <span class="toc-text">边缘点匹配</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B9%B3%E9%9D%A2%E7%82%B9%E5%8C%B9%E9%85%8D-1"><span class="toc-number">1.3.3.4.2.</span> <span class="toc-text">平面点匹配</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Ceres%E6%B1%82%E8%A7%A3-1"><span class="toc-number">1.3.3.5.</span> <span class="toc-text">Ceres求解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9B%B4%E6%96%B0%E4%BD%8D%E5%A7%BF%E5%92%8C%E5%9C%B0%E5%9B%BE"><span class="toc-number">1.3.3.6.</span> <span class="toc-text">更新位姿和地图</span></a></li></ol></li></ol></li></ol></li></ol></div></div></div></div></main><footer id="footer" style="background-image: url('https://tucang.cc/api/image/show/179aa07d6ac831122962767409dea79b')"><div id="footer-wrap"><div class="copyright">&copy;2022 By LMay</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (true){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><script src="/js/search/local-search.js"></script><div class="js-pjax"></div><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-fluttering-ribbon.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>